{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to giTrack \u00b6 Zero-touch time tracking \u00b6 giTrack is an utility that aims to make developer's life simpler by automatizing the frequent management's requirement of reporting the time spent. It does so using Git's commit messages and times for creating time entries, which to my experience correlates quiet a lot. It won't produce 100% accurate reports, but it should be \"good enough\" to meet the requirement (and it will at least motivate the developer to write proper commit's messages). Requirements \u00b6 Python 3.5 and higher Git Platform: Linux or MacOS Quick start \u00b6 Install giTrack: # Either using pip $ pip install gitrack # Or using pex build $ curl https://raw.githubusercontent.com/AuHau/gitrack/master/bin/install.sh | bash Go to the repository you want to track, initialize it and start tracking! $ gitrack init $ gitrack start # Do your work and commit it, when you are finished stop tracking $ gitrack stop Features \u00b6 Tracking time using Git Support for tasks Support for projects Prompt integration Providers \u00b6 giTracks has notion of providers which are the backends where the time entries are stored. Currently supported providers: Toggl","title":"About"},{"location":"#welcome-to-gitrack","text":"","title":"Welcome to giTrack"},{"location":"#zero-touch-time-tracking","text":"giTrack is an utility that aims to make developer's life simpler by automatizing the frequent management's requirement of reporting the time spent. It does so using Git's commit messages and times for creating time entries, which to my experience correlates quiet a lot. It won't produce 100% accurate reports, but it should be \"good enough\" to meet the requirement (and it will at least motivate the developer to write proper commit's messages).","title":"Zero-touch time tracking"},{"location":"#requirements","text":"Python 3.5 and higher Git Platform: Linux or MacOS","title":"Requirements"},{"location":"#quick-start","text":"Install giTrack: # Either using pip $ pip install gitrack # Or using pex build $ curl https://raw.githubusercontent.com/AuHau/gitrack/master/bin/install.sh | bash Go to the repository you want to track, initialize it and start tracking! $ gitrack init $ gitrack start # Do your work and commit it, when you are finished stop tracking $ gitrack stop","title":"Quick start"},{"location":"#features","text":"Tracking time using Git Support for tasks Support for projects Prompt integration","title":"Features"},{"location":"#providers","text":"giTracks has notion of providers which are the backends where the time entries are stored. Currently supported providers: Toggl","title":"Providers"},{"location":"configuration/","text":"Configuration \u00b6 giTrack has hierarchical configuration with three levels: Local config Store (eq. giTrack's internal storage) Global config (eq. config file common for all Git repos) The resolution of options is in order presented above. The config files (local and global) are INI styled text files that you can customize to your need. Local configuration \u00b6 .gitrack file placed in root of the Git repo Local configuration is the first place where giTrack looks to for option resolution. It can be part of the Git repo as common configuration for the team working in the repo. Store \u00b6 binary internal storage Pickled giTrack's state with some level of configuration and some other data about repos. Global configuration \u00b6 default.config file placed in the OS-specific application configuration folder (see: user_config_dir in appdirs ) INI options \u00b6 Overview of options for the INI config files. All following options belongs under [gitrack] section. This table display only the common giTrack's configuration. Each provider can have different set of custom options. For that see the provider's overview you want to use. Name Type Default Description provider str Name of provider to be used. ( Required ) project_support bool False Defines if project's support is enabled. Provider needs to support it. project str Defines ID or Name of Project to be associated with the created time entries. tasks_support bool False Defines if task's support is enabled. Provider needs to support it. tasks_mode str (enum) Possible values: static , dynamic_branch and dynamic_message . For explanation see Task support . tasks_regex str Python Regex that defines how the task's name or ID. It needs to contain capturing group with name task . tasks_value str In case of static mode, the name or ID to be used. update_check bool True giTrack will check upon invocation if there is a newer version available.","title":"Configuration"},{"location":"configuration/#configuration","text":"giTrack has hierarchical configuration with three levels: Local config Store (eq. giTrack's internal storage) Global config (eq. config file common for all Git repos) The resolution of options is in order presented above. The config files (local and global) are INI styled text files that you can customize to your need.","title":"Configuration"},{"location":"configuration/#local-configuration","text":".gitrack file placed in root of the Git repo Local configuration is the first place where giTrack looks to for option resolution. It can be part of the Git repo as common configuration for the team working in the repo.","title":"Local configuration"},{"location":"configuration/#store","text":"binary internal storage Pickled giTrack's state with some level of configuration and some other data about repos.","title":"Store"},{"location":"configuration/#global-configuration","text":"default.config file placed in the OS-specific application configuration folder (see: user_config_dir in appdirs )","title":"Global configuration"},{"location":"configuration/#ini-options","text":"Overview of options for the INI config files. All following options belongs under [gitrack] section. This table display only the common giTrack's configuration. Each provider can have different set of custom options. For that see the provider's overview you want to use. Name Type Default Description provider str Name of provider to be used. ( Required ) project_support bool False Defines if project's support is enabled. Provider needs to support it. project str Defines ID or Name of Project to be associated with the created time entries. tasks_support bool False Defines if task's support is enabled. Provider needs to support it. tasks_mode str (enum) Possible values: static , dynamic_branch and dynamic_message . For explanation see Task support . tasks_regex str Python Regex that defines how the task's name or ID. It needs to contain capturing group with name task . tasks_value str In case of static mode, the name or ID to be used. update_check bool True giTrack will check upon invocation if there is a newer version available.","title":"INI options"},{"location":"installation/","text":"Installation \u00b6 The easiest way to install giTrack is through pip: $ pip install gitrack This though might not serve your purpose as it might collide with your development environments (different virtualenvs etc). For such a situation there is pex build that can work correctly in any setup. To install pex build you can either manually download the appropriate build from latest release and put it on your $PATH , or you can use the automated script that will do it for you and place it to /usr/local/bin : $ curl https://raw.githubusercontent.com/AuHau/gitrack/master/bin/install.sh | bash Better safe then sorry It is always good idea to read through the installing script before you run it! Especially those which require sudo access. You should trust nobody with that privilege! That said there is nothing malicious in this one ;-)","title":"Installation"},{"location":"installation/#installation","text":"The easiest way to install giTrack is through pip: $ pip install gitrack This though might not serve your purpose as it might collide with your development environments (different virtualenvs etc). For such a situation there is pex build that can work correctly in any setup. To install pex build you can either manually download the appropriate build from latest release and put it on your $PATH , or you can use the automated script that will do it for you and place it to /usr/local/bin : $ curl https://raw.githubusercontent.com/AuHau/gitrack/master/bin/install.sh | bash Better safe then sorry It is always good idea to read through the installing script before you run it! Especially those which require sudo access. You should trust nobody with that privilege! That said there is nothing malicious in this one ;-)","title":"Installation"},{"location":"providers/","text":"Providers \u00b6 giTracks has notion of providers which are the backends where the time entries are stored. This page has overview of them and their's capabilities. Toggl \u00b6 Provider for time-tracking service toggl.com Task support: Yes Project support: Yes Additional capabilities: Possible to define a tags for all the giTrack's entries. INI options \u00b6 Name Type Default Description api_token str API token that defines the account to which the entries will be saved to. tags list List of tags that will be added to the time entry. For example ['gitrack', 'some other tag']","title":"Providers"},{"location":"providers/#providers","text":"giTracks has notion of providers which are the backends where the time entries are stored. This page has overview of them and their's capabilities.","title":"Providers"},{"location":"providers/#toggl","text":"Provider for time-tracking service toggl.com Task support: Yes Project support: Yes Additional capabilities: Possible to define a tags for all the giTrack's entries.","title":"Toggl"},{"location":"providers/#ini-options","text":"Name Type Default Description api_token str API token that defines the account to which the entries will be saved to. tags list List of tags that will be added to the time entry. For example ['gitrack', 'some other tag']","title":"INI options"},{"location":"usage/","text":"Usage \u00b6 The basic usage of giTrack is very simple. You have to do three steps: initialize the Git repo for giTrack usage - gitrack init start tracking - gitrack start work and commit it stop tracking - gitrack stop It is good idea to check out help pages ( --help ) for the commands to see possible options! Initialization \u00b6 During initialization gitrack collects configuration for the repository during bootstrap process. It also installs the Git hooks that are essential for the tracking itself. Skip of bootstrap If during the initialization .gitrack file is found in root of the repo, the bootstrap process is skipped and the configuration from this file is used instead. The installation process should be fairly smart and cover most of the basic cases, even with already existing post-commit hook. In case you want to handle installation of the hook on your own, you can initialize the repo with --no-hook option which skips the hook installation. In such a case then it is your responsibility to ensure that the command gitrack hooks post-commit is called on post-commit hook. In case you want to install only the hook without initialization you can use --install-hook You can specify destination of the bootstrapped configuration using -c / --config-destination option. More about configuration in separate section . Absolute paths giTrack currently uses absolute paths in many places, therefore moving the Git repository's folder after initialization will most likely break things. You have been warned. Task support \u00b6 giTrack enables you to assign the time entries created to tasks in the provider's domain. This has to be supported by your chosen provider. There are three modes how this is done: static mode - an static value defined by you during the init phase. dynamic mode based on branch name - dynamically parsed value from the current branch's name when the commit is created. dynamic mode based on commit message - dynamically parsed value from the commit message. For the dynamic modes the parsing is done using Python Regex that you have to supply during initialization. This regex needs to contain capturing group with name task , that needs to extract the name or ID of the task, that should be assigned to the time entry. Project support \u00b6 giTrack enables you also to assign the time entries created to specific project. Similarly to the task support, this needs to be supported by your chosen provider. During the init phase, you can choose to enable this feature and then you will specify ID or name of the project to be assigned to the time entries. Prompt integration \u00b6 gitrack prompt If you would like to keep overview of giTrack's status, you can use shell prompt's integration. There are two styles of the prompt integration: simple - a dot prepended to the shell which is shown either in green (tracking started) or red (no tracking) color displaying giTrack's status. clock - displays how long it is since the last time entry created / commit. Info The changes to the prompt are not exported hence if you want them persistent, you should place the activating command into your rc file. Shell completion \u00b6 gitrack completion giTrack supports commands/options completion for bash , zsh , PowerShell and fish shells. To enable the completion run gitrack completion install . This command will install completion based on your current shell, it mostly consist of adding _GITRACK_COMPLETE variable to your rc file. If you want to inspect details you can run gitrack completion show . Direnv tip \u00b6 For even more automatization, you can use awesome tool direnv for automatically starting tracking when you change directory into your Git repo. Unfortunately there is currently no support for unloading-hook (the support for it is discussed here , you can ask authors to incorporate into their work), so you still have to stop your time tracking manually when you are done.","title":"Usage"},{"location":"usage/#usage","text":"The basic usage of giTrack is very simple. You have to do three steps: initialize the Git repo for giTrack usage - gitrack init start tracking - gitrack start work and commit it stop tracking - gitrack stop It is good idea to check out help pages ( --help ) for the commands to see possible options!","title":"Usage"},{"location":"usage/#initialization","text":"During initialization gitrack collects configuration for the repository during bootstrap process. It also installs the Git hooks that are essential for the tracking itself. Skip of bootstrap If during the initialization .gitrack file is found in root of the repo, the bootstrap process is skipped and the configuration from this file is used instead. The installation process should be fairly smart and cover most of the basic cases, even with already existing post-commit hook. In case you want to handle installation of the hook on your own, you can initialize the repo with --no-hook option which skips the hook installation. In such a case then it is your responsibility to ensure that the command gitrack hooks post-commit is called on post-commit hook. In case you want to install only the hook without initialization you can use --install-hook You can specify destination of the bootstrapped configuration using -c / --config-destination option. More about configuration in separate section . Absolute paths giTrack currently uses absolute paths in many places, therefore moving the Git repository's folder after initialization will most likely break things. You have been warned.","title":"Initialization"},{"location":"usage/#task-support","text":"giTrack enables you to assign the time entries created to tasks in the provider's domain. This has to be supported by your chosen provider. There are three modes how this is done: static mode - an static value defined by you during the init phase. dynamic mode based on branch name - dynamically parsed value from the current branch's name when the commit is created. dynamic mode based on commit message - dynamically parsed value from the commit message. For the dynamic modes the parsing is done using Python Regex that you have to supply during initialization. This regex needs to contain capturing group with name task , that needs to extract the name or ID of the task, that should be assigned to the time entry.","title":"Task support"},{"location":"usage/#project-support","text":"giTrack enables you also to assign the time entries created to specific project. Similarly to the task support, this needs to be supported by your chosen provider. During the init phase, you can choose to enable this feature and then you will specify ID or name of the project to be assigned to the time entries.","title":"Project support"},{"location":"usage/#prompt-integration","text":"gitrack prompt If you would like to keep overview of giTrack's status, you can use shell prompt's integration. There are two styles of the prompt integration: simple - a dot prepended to the shell which is shown either in green (tracking started) or red (no tracking) color displaying giTrack's status. clock - displays how long it is since the last time entry created / commit. Info The changes to the prompt are not exported hence if you want them persistent, you should place the activating command into your rc file.","title":"Prompt integration"},{"location":"usage/#shell-completion","text":"gitrack completion giTrack supports commands/options completion for bash , zsh , PowerShell and fish shells. To enable the completion run gitrack completion install . This command will install completion based on your current shell, it mostly consist of adding _GITRACK_COMPLETE variable to your rc file. If you want to inspect details you can run gitrack completion show .","title":"Shell completion"},{"location":"usage/#direnv-tip","text":"For even more automatization, you can use awesome tool direnv for automatically starting tracking when you change directory into your Git repo. Unfortunately there is currently no support for unloading-hook (the support for it is discussed here , you can ask authors to incorporate into their work), so you still have to stop your time tracking manually when you are done.","title":"Direnv tip"}]}